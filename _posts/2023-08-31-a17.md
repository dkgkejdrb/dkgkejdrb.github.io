---
layout: single
title:  "Node.js 백엔드 스터디(20) - OAuth를 사용한 구글 로그인 인증하기"
categories: Backend
tag: [Backend, NestJS]
toc: true 





































---

### 들어가기전에...

내가 다니는 회사에서 통합로그인에 대한 이슈가 있었던걸로 기억한다. 그리고, 임대형 사이트를 사용해본적이 있었는데, 통합로그인을 지원하느냐 안하느냐에 따라 회원가입 편차가 상당히 컸던걸로 기억한다. 이번 스터디에서는 OAuth, 소셜 로그인 기능에 대해 스터디해보았따.

------

###  OAuth  란?

OAuth는 Open Authorization의 약자로서 개방형 인가의 표준이라는 뜻으로, 소셜 로그인이다. 소셜 로그인은 유저가 해당 웹사이트에 가입한 ID와 패스워드 대신 다른 사이트에 있는 유저 정보를 사용해 인증하는 기능이다.

하지만, OAuth는 인증이라기 보다 인가의 관점에서 보아야 한다. 소셜 로그인 후 팝업이 뜨면서 권한을 요청하는데, 이 때 인증에 필요한 정보인 이름, 이메일 정보 등을 다른 사이트에 요청한다.

OAuth는 1.0, 2.0, 2.1 버전이 있으며, 현재 2.0 버전을 가장많이 사용한다.

OAuth2를 본격적으로 알아보기 전에 인증, 인가, 액세스 토큰, 리프레시 토큰 등의 주요 용어를 아래와 같이 알아보자.

- 인증: 리소스에 접근 자격이 있는지 검증한다. OAuth에서 리소스는 보호된 정보를 의미한다
- 인가: 자원에 접근할 권한을 부여하는 과정. 인가가 완료되면 리소스의 접근 권한 정보가 있는 액세스 토큰을 클라이언트에게 보낸다
- 액세스 토큰: 리소스 서버에서 리소스 소유자의 보호된 정보를 획득할 때 사용하는 만료 기간이 있는 토큰
- 리프레시 토큰: 액세스 토큰이 만료되었을 때 갱신하는 용도로 사용하는 토큰. 액세스 토큰보다 만료 기간을 길게 가져간다
- 리소스 소유자: 리소스는 사용자의 보호된 정보를 말하며 이런 정보에 접근하도록 자격을 부여하는 사람을 말한다.
- 클라이언트: 리소스를 사용하려고 접근을 요청하는 앱을 의미한다
- 리소스 서버: 사용자의 보호된 자원을 가지고 있는 서버
- 인가 서버: 인증/인가를 수행하는 서버로 클라이언트의 접근 자격을 확인하고 액세스 토큰을 발급해 권한을 부여한다

------

### OAuth 프로토콜 흐름

![image-20230901092607210](../../images/2023-08-31-a17/image-20230901092607210.png)

<참조: p.430(패스포트와 세션을 사용한 인증 과정) Node.js 백엔드 개발자 되기, 골든래빗, 박승규 지음>

1번. 클라이언트가 리소스 소유자에게 권한 부여를 요청

2번. 클라이언트는 권한을 부여 받음

- 인증 코드(Autorization Code)
- 암묵적인(Implicit) 방법
- 리소스 소유자의 암호 자격증명(Resource Owner Password Credentials)
- 클라이언트 자격증명(Client Credentials)

3번. 클라이언트는 2번에서 받은 정보를 통해 액세스 토큰을 인가 서버에 요구

4번. 인가 서버에서는 클라이언트를 인증하고 유혀성 검사를 함. 유효한 경우 액세스 토큰을 발급

5번. 클라이언트가 리소스 서버에 보호된 리소스를 요청. 요청 시에는 액세스 토큰을 사용

6번. 리소스 서버는 액세스 토큰의 유효성을 검사하고 유효한 경우 보호된 자원 정보를 보내줌

------

### 액세스 토큰을 재발행하는 흐름

액세스 토큰 만료 시 리프레시 토큰을 사용해 액세스 토큰을 재발행할 수 있다

![image-20230901093649280](../../images/2023-08-31-a17/image-20230901093649280.png)

<참조: p.431(패스포트와 세션을 사용한 인증 과정) Node.js 백엔드 개발자 되기, 골든래빗, 박승규 지음>

1번. 클라이언트는 인가 서버에 인증을 하고 액세스 토큰을 요청한다

2번. 인가 서버는 클라이언트를 인증하고 유효성 검증을 한 후에 문제가 없으면 액세스 토큰과 리프레시 토큰을 발급한다

3번. 클라이언트가 리소스 서버에 액세스 토큰을 보내면서 보호된 리소스를 요청

4번. 리소스 서버가 액세스 토큰의 유효성을 검증하고 유효한 경우 리소스를 내려준다

5번. 액세스 토큰 만료 시에도 클라이언트는 액세스 토큰을 리소스 서버에 전달한다. 클라이언트가 액세스 토큰이 만료된 것을 알고 있다면, 7로 가게 되고, 모른다면 만료된 액세스 토큰을 전달한다

6번. 리소스 서버에서는 액세스 토큰이 만료되었으므로 잘못된 토큰 에러를 발생시킨다

7번. 클라이언트에서는 액세스 토큰이 만료되어 에러가 발생했으므로 리프레시 토큰을 인가 서버로 전달해 새 액세스 토큰을 요청한다

8번. 인가 서버는 리프레시 토큰이 유효한 경우 새로운 액세스 토큰을 발급한다. 선택적으로 리프레시 토큰도 재발급한다

------

### 1. 구글 OAuth를 사용하기 위한 준비

클라이언트에서 구글의 OAuth 인가 서버에 접속하려면 OAuth 클라이언트 ID와 비밀번호가 필요하다. 아래는 생성을 위한 순서이다. 

- (1) 구글 클라우드에서 프로젝트 생성
- (2) OAuth 동의 화면을 생성
- (3) 클라이언트 ID 생성

------

#### 순서 1. 구글 클라우드에서 프로젝트 생성

구글 클라우드(console.cloud.google.com)에 접속한다

순서 1-1. 프로젝트 선택 > 새 프로젝트

![image-20230901095425247](../../images/2023-08-31-a17/image-20230901095425247.png)

------

순서 1-2. 프로젝트 이름 입력 > 만들기

![image-20230901095545895](../../images/2023-08-31-a17/image-20230901095545895.png)

------

순서 1-3. 생성한 프로젝트 선택 > API 및 서비스 > OAuth 동의 화면

![image-20230901095822413](../../images/2023-08-31-a17/image-20230901095822413.png)

------

순서 1-4. 외부 > 만들기

![image-20230901095919511](../../images/2023-08-31-a17/image-20230901095919511.png)

------

순서 1-5. [OAuth 동의 화면]에서 앱 이름 > 사용자 지원 이메일 > 개발자 연락처 청보 > 저장 후 계속

![image-20230901100122524](../../images/2023-08-31-a17/image-20230901100122524.png)

![image-20230901100128695](../../images/2023-08-31-a17/image-20230901100128695.png)

------

순서 1-6. [범위]에서 설정 없이 저장 후 계속

------

순서 1-7. [테스트 사용자]에서 설정 없이 저장 후 계속

------

순서 1-8. [요약]에서 대시보드로 돌아가기

------

#### 순서 2. OAuth 클라이언트의 ID와 비밀번호 만들기

순서 2-1. 사용자 인증 정보 > 사용자 인증정보 만들기 > OAuth 클라이언트 ID를 눌러서 인증 정보 설정 화면으로 이동

![image-20230901101735129](../../images/2023-08-31-a17/image-20230901101735129.png)

------

순서 2-2. [OAuth 클라이언트 ID 만들기] 에서 애플리케이션 유형: 웹 애플리케이션 > 이름: 웹 클라이언트 1 > 승인된 자바스크립트 원본: http://localhost:3000 > 승인된 리디렉션 URI: http://localhost:3000/auth/google > 만들기

![image-20230901102138178](../../images/2023-08-31-a17/image-20230901102138178.png)

------

순서 2-3. 생성된 클라이언트 ID, 클라이언트 보안 비밀번호를 기억해두고, 유출되지 않도록 조심하자

![image-20230901102755848](../../images/2023-08-31-a17/image-20230901102755848.png)

------

### 2. 구글 OAuth 구현 순서

![image-20230901103322161](../../images/2023-08-31-a17/image-20230901103322161.png)

1번. 구글 OAuth를 사용해 구글에 사용자 정보를 요청하면 이메일과 프로필 정보를 OAuth 스트래티지 파일(GoogleStrategy)의 validate() 메서드에서 콜백으로 받는다

2번. 이때 넘어오는 데이터는 액세스 토큰(리프레시 토큰), 프로필 정보다

3번. 프로필에는 식별자로 사용되는 ID가 있으며 providerId로 부른다. name 객체도 넘어오는데 성(familyName)과 이름(givenName) 속성을 가지고 있다. 프로젝트에서 유저 정보의 키로 사용하는 이메일 정보도 가지고 있다

#### 그래서, 받아온 데이터를 어떻게 다룰거지?

책에서 가이드해주는 대로 구글 OAuth로 받은 데이터를 지난 장에서 다뤘던 '[패스포트와 세션을 사용한 인증 구현](https://dkgkejdrb.github.io/backend/a16/)'에서 살펴본 세션에 저장해서 인증하는 방법을 사용하려 한다.

책에 따르면, 앞으로 만들 앱에서 유저 식별자는 이메일이다. 구글 OAuth로 가입한 유저는 패스워드가 없으므로, 구글 OAuth로 가입한 유저라는 것을 알 수 있도록 구글 OAuth의 식별자인 providerId를 같이 저장한다. 그러므로 User 엔티티 수정이 필요하다.

※ 엔티티란? SQLite에서 다루었었는데, 데이터베이스에서 엔티티는 한 건의 자료를 구성하는 데이터를 의미한다. ORM 프레임워크에서는 테이블과 매핑하는 클래스를 엔티티라고 하며 TypeORM의 경우 @Entity() 데코레이터를 붙인 클래스를 의미한다

GoogleStrategy의 validate() 메서드에서는 인증 시 유저 데이터가 있으면 가져오고 없으면 저장하는 로직이 필요하다. 이 로직을 UserService에 작성한다. 관련 유저 데이터는 User 엔티티에 담는다.

마지막으로 Auth 컨트롤러의 테스트에 사용할 메서드 두 개를 추가한다. 하나는 OAuth 로그인 화면을 띄울 메서드이고 다른 하나는 OAuth 리다이렉트에 사용할 메서드이다. 컨트롤러에는 가드가 필요하다. GoogleAuthGuard도 만든다. 리다이렉트 시 GoogleStrategy의 validate 메서드가 실행된다

그리고 GoogleStrategy 설정 시 민감한 정보가 들어가므로 NestJS config도 설정해야 한다.

![image-20230901105752335](../../images/2023-08-31-a17/image-20230901105752335.png)













#### 순서 1. passport 라이브러리 설치

- 



### 참고

- [Node.js 백엔드 개발자 되기, 골든래빗, 박승규 지음](https://goldenrabbit.co.kr/product/be_node_backend/)



### 다음에 다루게 될 것

- OAuth를 사용한 구글 로그인 인증하기

