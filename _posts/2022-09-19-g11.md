---
layout: single
title:  "리액트: 자습서 탐독"
categories: R&D
tag: [React.js]
toc: true 











---

## 1. React 리서치는 어떻게 할건데?

React 공식사이트에서 제공하는 '문서'와 자습서'를 탐독하고 실습하여 최대한 속성으로 React의 기본적인 사항들을 마스터하도록 한다.

[[React 공식사이트 안내서 링크]](https://ko.reactjs.org/docs/hello-world.html)

[[React 공식사이트 자습서 링크]](https://ko.reactjs.org/tutorial/tutorial.html)





## 2. React 란?

- 클라이언트 사이드의 JS 라이브러리 제공과 웹 개발에 필요한 현대적이고 반응적인 사용자 인터페이스를 구축하기 위한 모든 것을 지원하는 프레임워크이다.
- 선언적, 구성 요소 중심의 접근방식을 사용한다.
- 리액트는 싱글 페이지 어플리케이션(SPA)이나 모바일 어플리케이션 개발에 사용한다.
- 리액트는 페이스북의 소프트웨어 엔지니어 Jordan Walke가 개발하였다.

### 싱글 페이지 어플리케이션(SPA: Single-Page-Application)

SPA 방식은 서버가 하나의 HTML 페이지만 보낸 후, React가 UI를 인계받아 제어하는 방식이다.





## 3. 새로운 React 프로젝트 만들기

- 순서1. 새로운 프로젝트 생성하기

```
npx create-react-app my-app
```



- 순서2. 프로젝트 경로 접근하기

```
cd my-app
```



- 순서3. (프로젝트 경로에 접근한 상태) 프로젝트 열기

```
npm start
```



- 순서4. src/ 폴더에 있는 모든 파일 삭제

```
del *
```



- 순서5. 상위폴더로 돌아가기

```
cd ..
```



- 순서6. src/ 폴더에 index.css 파일 생성하기
- 순서7. src/ 폴더에 index.js 파일 생성하기
- 순서8. 위에서 생성한 index.js 의 상단에 아래 세 줄을 추가하기

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
```





## 4. React 엘리먼트: JSX 표현식

JSX는 JavaScript 코드 안에서 UI 관련 작업을 함께 하는 것을 말하는데, 본질적으로 렌더링 로직이 UI 로직(이벤트가 처리되는 방식, 시간에 따라 state가 변하는 방식, 화면에 표시하기 위해 데이터가 준비되는 방식 등)과 연결된다.

JSX는 if, for 등을 사용하거나, 변수를 할당하고, 인수를 받아, 함수를 반환할 수도 있다.

[예시 1 - JavaScript 함수 호출의 결과인 formatName(user)를 h1 엘리먼트에 포함한 경우]

```react
const user = () => {
    firstName = 'DK';
    lastName = ' Lee';
}


const formatName = (user) => {
    return user.firstName + ' ' + user.lastName;
}

const element = (
    <h1>
        Hello, {formatName(user)}!
    </h1>
);
```



[예시 2 - JSX 표현식이 반환값으로 사용된 예]

```react
const getGreeting = (user) => {
    if (user) {
        return <h1>Hello, {formatName(user)}!</h1>;
    }
    return <h1>Hello, Stranger.</h1>
}
```









## 5. React 엘리먼트: JSX 자식 요소 정의

JSX 태그는 자식을 포함할 수 있는데, 자식이 없는 태그인 경우는 반드시 '/'로 닫아주어야 한다.

[예시 1 - 자식이 포함된 예]

```react
const element = (
	<div>
		<h1>Hello!</h1>
		<h2>Good to see you here.</h2>
	</div>
);
```



[예시 2 - 더 이상의 요소의 태그가 없는 경우]

```react
const element = <img src={user.avatarUrl} />;
```









## 6. React 엘리먼트: JSX의 객체 표현

React 엘리먼트는 React 앱의 가장 작은 단위이며, 화면이 어떻게 나타나야하는지를 담고 있다.

다음 두 예시는 동일한 예시이다.

```react
const element = (
    <h1 className="greeting">
        Hello, world!
    </h1>
);
```

```react
const element = React.createElement(
    'h1',
    {className: 'greeting'},
    'Hello, world!'
);
```



 여기서 React.createElement() 는 버그가 없는 코드를 작성하는데 도움이 되도록 몇 가지 검사를 수행하며, 기본적으로 다음과 같은 객체를 생성한다.

```react
const element = {
	type: 'h1',
	props: {
		className: 'greeting',
		children: 'Hello, world!'
	}
};
```



element 는 변수처럼 보이지만, 안에 화면에서 보고 싶은 것을 JSX 표현식으로 나타낸 'React 엘리먼트'라 한다.

이렇게 만들어진 React 엘리먼트를 DOM에 렌더링하면 화면에서 볼 수 있다.

여기서 주의할 점은, 엘리먼트와 컴포넌트를 혼동해서는 안된다는 점이다.









## 7. React 엘리먼트: 엘리먼트 렌더링

React는 모든 엘리먼트를 React DOM에서 관리하는데, 아래와 같은 요소를 '루트(root)' DOM 노드라고 한다.

```html
<div id="root"></div>
```



[예시 - element를 root DOM에 렌더링 한 예]

```react
const root = ReactDOM.createRoot(
    document.getElementById('root')
);
const element = <h1>Hello, world!</h1>;
root.render(element);
```









## 8. React 엘리먼트: 렌더링 된 엘리먼트 업데이트하기

React 엘리먼트는 불변객체로서, 엘리먼트를 생성한 이후에는 자식이나 속성을 변경할 수 없다.

하지만, UI를 업데이트할 수 있는 유일한 방법이 있는데 아래와 같이 특정 함수를 호출할 때마다 새로운 엘리먼트를 생성하여 root.render()로 전달하는 방법이 있다.

```react
const root = ReactDOM.createRoot(
    document.getElementById('root')
);

let tick = () => {
    // 새로운 엘리먼트를 생성하여 불변객체를 DOM에 렌더링할 수 있음
    const element = (
        <div>  
            <h1>Hello!</h1>
            <h2>It is {new Date().toLocaleTimeString()}.</h2>
        </div>
    );
    root.render(element);
}

setInterval(tick, 1000);
```









## 9. React 엘리먼트: 똑똑한 React DOM

React DOM은 해당 엘리먼트와 그 자식 엘리먼트를 이전의 엘리먼트와 비교하여, 바뀌어있는 속성만을 업데이트한다.

매초 전체 UI를 다시 그리도록 엘리먼트 로직을 작성했지만, React DOM은 내용이 변경된 텍스트 노드만 업데이트한다.









## 10. React 컴포넌트: 함수 컴포넌트와 클래스 컴포넌트

개념적으로 컴포넌트는 Javascript 함수와 유사하다. 'props'라고 하는 임의의 입력을 받은 후, 화면에 어떻게 표시되는지를 기술한 React 엘리먼트를 반환하는 구조이다.

[예시 1 - 함수 컴포넌트]

```react
const Welcome = (props) => {
    return <h1>Hello, {props}</h1>;
}

root.render(Welcome('이동규'));
```



[예시 2 - 클래스 컴포넌트]

```react
class Welcome extends React.Component {
    render() {
        return <h1>Hello, {this.props.name}</h1>;
    }
}
```



React의 관점에서 볼 때, 위 두 가지 유형의 컴포넌트는 동일하다. (위 예제에서 클래스 컴포넌트의 constructor는 생략되어 있다.)









## 11. *React 컴포넌트: 컴포넌트 렌더링

엘리먼트의 이름을 나타낼 때, 컴포넌트의 이름을 사용할 수 있다.

많은 예제에서 element를 렌더링할 때, 컴포넌트의 이름으로 엘리먼트 이름을 사용하니 숙달하도록 하자.

그리고 컴포넌트의 이름을 소문자로 사용하면, 태그로 처리하여 정상적으로 렌더링이 되지 않기에 반드시 대문자로 컴포넌트의 이름을 정해야한다.

```react
const Welcome = (props) => {
    return <h1>Hello, {props.name}!</h1>;
}

const root = ReactDOM.createRoot(document.getElementById('root'));

// 컴포넌트의 이름이 엘리먼트 이름으로 사용
const element = <Welcome name="Sara" />;


// 에러
const element = <welcome name="Sara" />;

root.render(element);
```

 







## 12. *React 컴포넌트: 컴포넌트 합성

컴포넌트는 자신의 출력에 다른 컴포넌트를 참조할 수 있다. 쉽게 말하면, JS의 nest 함수와 비슷한 구조라 보면 된다. 단, React 컴포넌트는 반드시 반환값으로 다른 컴포넌트를 지정하여 화면에 반복 출력되게 해야 합성에 의미가 있다.

```react
const Count = (props) => {
    return <h1>This is {props.cnt}</h1>
};

const CountList = () => {
    return (
        <div>
            <Count cnt="1" />
            <Count cnt="2" />
            <Count cnt="3" />
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
const element = <CountList />;

// This is 1
// This is 2
// This is 3
root.render(element);
```









## 13. *React 컴포넌트: 컴포넌트 추출

컴포넌트를 엘리먼트를 기준으로 추출하면, **(1)추출된 컴포넌트들이 재사용, (2)클린코드**가 가능해진다.

컴포넌트를 추출할 때에는 **가장 안쪽에 있는 컴포넌트부터 시작**하도록한다. 아래 중첩 구조로 이루어져 추출하기 어려운 예시 코드를 통해 연습해보도록하자.



아래 코드를 분석해보면, Comment 의 자식으로 UserInfo, comment-text, comment-date가 있고, UserInfo의 자식으로 Avart가 있다.

먼저, UserInfo를 분리하기 전에 가장 안쪽에 있는 Avatar부터 분리하도록 한다.

```react
const Comment = (props) => {
    return (
        <div className="Comment">
            <div className="UserInfo">
                <img className="Avatar" ← Avatar부터 분리
                    src={props.author.avatarUrl}
                    alt={props.author.name}
                />
                <div className="UserInfo-name">
                    {props.author.name}
                </div>
            </div>
            
            <div className="Comment-text">
                {props.text}
            </div>
            <div className="Comment-date">
                {formatDate(props.date)}
            </div>
        </div>
    );
}
```



함수 컴포넌트를 구성할 때, 함수 컴포넌트의 기본 구조를 반드시 기억하고 분류하도록 하자. 함수 컴포넌트의 기본 구조는 (1) props를 인수로 받고 (2) 엘리먼트를 반환하는 구조이다.

```react
const Avatar = (props) => {
	return (
		<img className="Avatar"
			src={props.author.avatarUrl}
			alt={props.author.name}
		/>
	);
}
```



코드가 조금 단순해졌다.

다음으로 UserInfo 컴포넌트를 추출하도록 하자. UserInfo는 자식으로 Avatar 렌더링, UserInfo-name을 갖고 있다.

```react
const Comment = (props) => {
    return (
        <div className="Comment">
            <div className="UserInfo">
                <Avatar user={props.author} ← 추출한 Avatar 렌더링
                <div className="UserInfo-name">
                    {props.author.name}
                </div>
            </div>
            
            <div className="Comment-text">
                {props.text}
            </div>
            <div className="Comment-date">
                {formatDate(props.date)}
            </div>
        </div>
    );
}
```



```react
const UserInfo = (props) => {
    return (
		<div className="UserInfo">
			<Avatar user={props.author} ← 추출한 Avatar 렌더링
				<div className="UserInfo-name">
                        {props.author.name}
                </div>
		</div>
    );
}
```







## 4. 초기 코드 살펴보기

'틱택토' 게임을 리액트로 구현해볼 건데, 자습서에 주어지는 기본 틱택토의 기본 코드는 아래와 같다.

[index.js]

```react
class Square extends React.Component {
    render() {
      return (
        <button className="square">
          {/* TODO */}
        </button>
      );
    }
  }
  
  class Board extends React.Component {
    renderSquare(i) {
      return <Square />;
    }
  
    render() {
      const status = 'Next player: X';
  
      return (
        <div>
          <div className="status">{status}</div>
          <div className="board-row">
            {this.renderSquare(0)}
            {this.renderSquare(1)}
            {this.renderSquare(2)}
          </div>
          <div className="board-row">
            {this.renderSquare(3)}
            {this.renderSquare(4)}
            {this.renderSquare(5)}
          </div>
          <div className="board-row">
            {this.renderSquare(6)}
            {this.renderSquare(7)}
            {this.renderSquare(8)}
          </div>
        </div>
      );
    }
  }
  
  class Game extends React.Component {
    render() {
      return (
        <div className="game">
          <div className="game-board">
            <Board />
          </div>
          <div className="game-info">
            <div>{/* status */}</div>
            <ol>{/* TODO */}</ol>
          </div>
        </div>
      );
    }
  }
  
  // ========================================
  
  const root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(<Game />);
```



여기서 3개의 클래스를 볼 수 있는데, React에서는 이를 'React 컴포넌트'라고 한다.

컴포넌트는 React.Component를 상속받고 있는 javascript의 클래스 모양을 하고 있다.

Square는 button을 렌더링하고 Board는 사각형 9개를 렌더링하며, Game은 게임판을 렌더링하고 있다.









## 5. 부모 → 자식 컴포넌트로 props를 통해 데이터 전달하기

```react
class Square extends React.Component {
    render() {
      return (
        // 부모 컴포넌트로부터 props를 전달받아 버튼에 표시
        <button className="square">
          {this.props.value}
        </button>
      );
    }
  }
  
class Board extends React.Component {
    renderSquare(i) {
		// 자식 컴포넌트 Square에 value prop을 전달
		return <Square value={i} />;
    }
 ...
 }
```









## 6. 이벤트 리스너 등록하기

이벤트 리스터 등록 시, 화살표 함수형태를 사용하도록 하자. (단, function 함수일 때의 형태도 기억하도록 하자)

```react
class Square extends React.Component {
  render() {
    return (
	  // 클릭 이벤트 리스너 추가
      <button className="square" onClick={function() { console.log('click'); }}>
        {this.props.value}
      </button>
    );
  }
}

// <button className="square" onClick={() => console.log('click') }>
```











## 7. 컴포넌트 클래스의 생성자 설정하기

모든 React 컴포넌트 클래스는 생성자를 가질 때, super(props) 구문부터 작성해야 한다.

```react
class Square extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            value: null,
        };
    }
    ...
}
```



Square를 클릭할 때 현재 state 값을 표시하기 위해 render 함수를 변경한다.

Square의 render 함수 내부에서 onClick 핸들러를 통해 this.setState를 호출하는 것으로 React에게 button을 클릭할 때 Square가 다시 렌더링해야 한다고 알릴 수 있다.

클릭했을 때, Square의 this.state.value 는 'X' 가 되어 게임 판에서 X가 나타난다.

컴포넌트에서 setState를 호출하면 React는 자동으로 컴포넌트 내부의 자식 컴포넌트 역시 업데이트한다.

```react
class Square extends React.Component {
...
    render() {
      return (
        // 부모 컴포넌트(Board)로부터 props를 전달받아 버튼에 표시
        <button 
        className="square" 
        onClick={() => this.setState({value: 'X'})}
        >
            {this.state.value}
        </button>
      );
    }
  } 
```







## 8. 9개의 sqaure에 전달할 state 값을 부모 컴포넌트에서 관리하기

부모 컴포넌트(Board)는 props를 사용하여 자식 컴포넌트에 state를 다시 전달할 수 있다.

이러한 방식으로 컴포넌트끼리 또는 부모 컴포넌트와 동기화할 수 있게 한다.

state는 원래 자식 컴포넌트(Square)에 있었지만, 부모 컴포넌트(Board)에서 props를 통해 state를 다시 전달하였는데, 이를 부모 컴포넌트로 끌어올렸다고 표현한다.

```react
  class Board extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            // 9개의 square에 전달할 state 값을 부모 컴포넌트(Board)에서 관리
            squares: Array(9).fill(null),
        }
    }
    ...
}
```





## 9. 다음 리서치할 내용

[[State 끌어올리기]](https://ko.reactjs.org/tutorial/tutorial.html#lifting-state-up)
