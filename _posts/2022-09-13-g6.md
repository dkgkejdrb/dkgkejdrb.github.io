---
layout: single
title:  "JavaScript: 객체 리터럴, 구조, 함수, 배열 메서드&콜백, 최신 기능들"
categories: 웹개발
tag: [웹-Frontend, JavaScript]
toc: true 









---

## 1. 객체(Object) 리터럴: 개요

JS의 객체(Object)는 배열과 마찬가지로 여러 데이터 조각을 저장할 수 있다.

배열과 객체의 차이점은 배열에서는 데이터의 순서가 중요했지만, 객체는 '**key:value**'의 쌍 이를 property 라고 하는데, 이 property 를 이용해서 데이터를 저장하고 호출할 수 있다.

객체 안에 property 를 선언할 때는 변수, 배열 선언과는 다르게 let, const 가 필요 없고, key 값이 문자열이어도 따옴표를 함께 작성할 필요가 없다.

대신에 ':' 를 사이에 두고, key와 value를 구분하여 정의하면 된다.

```javascript
const restaurant = {
    name: 'Ichiran Ramen',
    address: `${Math.floor(Math.random() * 100) + 1} Johnson Ave`,
    city: 'Brooklyn',
    state: 'NY',
    zipcode: '11206'
};
```









## 2. 객체(Object) 리터럴: property 액세스

객체의 데이터에 액세스하는 방법은 아래와 같이 두 가지 방법이 있다.

- (방법 1) **객체['key']** : **깊은 참조.** key의 데이터 타입과 상관없이 반드시 따옴표와 key 를 함께 작성하는 것이 좋다. 하지만, 따옴표를 생략하고 key 만 적어도 작동하지만, 객체에서 모든 key 는 문자열로 변환되어 저장되기 때문에 이러한 작동 원리를 이해하고 따옴표와 함께 사용하도록 하자.

```javascript
const years = {2022: 'Good', 2020: 'Bad', birthDay: 1987};

// Good
console.log(years['2022']);

// Bad
console.log(years[2020]);
```



- (방법 2) **객체.key** : **얕은 참조.**

```javascript
const home = {
    address: 'Seodaemoon',
    phoneNumber: '02-359-0123'
};

// Seodaemoon, 02-359-0123
console.log(`${home.address}, ${home.phoneNumber}`);
```





- 방법 1과 같이 데이터 호출 시, 따옴표와 key 를 함께 작성해야 하는 이유는 무엇일까?

  - 객체에서 만들어진 모든 key 는 문자열로 변환되기 때문에 되도록이면 따옴표와 함께 작성하는 것이 좋다. 방법 1의 대괄호의 의미는 '평가한다'는 뜻이기 때문에 평가 후 액세스를 통해 다양한 기능으로 활용할 수 있기 때문이다.

- 그렇다면, 방법 1과 방법 2 중에서 어떠한 방법을 사용하는 것이 좋을까?

  - 방법 1을 사용하는 것이 좋다. 왜냐하면 대괄호를 사용하는 방법 1이 방법 2에 비해 더 깊은 참조가 가능하기 때문이다.

  ```javascript
  const home = {
      address: 'Seodaemoon',
      phoneNumber: '02-359-0123'
  };
  
  let address = 'Jongro';
  
  // Jongro
  console.log(address);
  // undefined, 오류
  console.log(home[address]);
  // Seodaemoon
  console.log(home[`address`]);
  // Seodaemoon
  console.log(home.address);
  ```









## 3. 객체(Object) 리터럴: property 추가, 수정

```javascript
const midTerms = {Thomas: 'C+', Danielle: 'A'};

// property 추가 가능
midTerms['Ezra'] = 'F';

// prperty 추가 불가능
// midTerms[Shelly] = 'A+';


// property 수정
midTerms['Thomas'] = 'S';
```









## 4. 객체(Object) 리터럴: 배열과 객체 네스트 구성

배열과 객체를 같이 섞어 사용하면 기능이 강력해지며, 섞어서 사용하는 경우는 실무에서 매우 흔하게 일어난다.

배열과 객체를 혼합하여 사용하는 경우, 각 기능을 정리할 필요가 있다.

먼저, 배열은 데이터의 순서가 중요한 경우 사용되는 구조이고, 객체는 순서와 상관없이 property로 데이터의 묶음을 저장할 때 사용한다.

아래는 직접 제작해본 방명록 게시판 예시이다.

```javascript
// 방명록 게시판 시스템
// 방명록(배열)에는 '유저(객체)', '포스트 글(변수)', '게시 날짜(변수)'
// 유저(객체)에는 '이름', '생년월일'

const comments = [
    {
        user: { 
            id : 'ehdrb3663',
            name : '이동규',
            birthDay : 19871016 
        }, 
        txt: '안녕하세요~ 첫 방문입니다.',
        date: '2021-12-01'
    },

    {
        user: { 
            id : 'ejdrb87',
            name : '이동건',
            birthDay : 19870913 
        }, 
        txt: 'Hello New World!',
        date: '2021-12-02'
    },

    {
        user: { 
            id : 'eidung89',
            name : '이동팔',
            birthDay : 20010134 
        }, 
        txt: '새글 남겨요~ 등업해주세요.',
        date: '2021-12-03'
    },
]

// {user: {…}, txt: '안녕하세요~ 첫 방문입니다.', date: '2021-12-01'}
// {user: {…}, txt: 'Hello New World!', date: '2021-12-02'} 
// {user: {…}, txt: '새글 남겨요~ 등업해주세요.', date: '2021-12-03'}
console.log(comments[0], comments[1], comments[2]);

// ehdrb3663 ejdrb87 eidung89
console.log(comments[0].user.id, comments[1].user.id, comments[2].user.id);

// 이동규 이동건 이동팔
console.log(comments[0].user['name'], comments[1].user['name'], comments[2].user['name']);

// 안녕하세요~ 첫 방문입니다. Hello New World! 새글 남겨요~ 등업해주세요.
console.log(comments[0]['txt'], comments[1]['txt'], comments[2]['txt']);

// 2021-12-01 2021-12-02 2021-12-03
console.log(comments[0].date, comments[1].date, comments[2].date);
```









## 5. 루프(Loop): for 문

JS 의 for 문은 C와 비슷하다.

```javascript
// 1: da ba dee da ba daa
// 2: da ba dee da ba daa
// 3: da ba dee da ba daa
// 4: da ba dee da ba daa
// 5: da ba dee da ba daa
// 6: da ba dee da ba daa
// 7: da ba dee da ba daa
// 8: da ba dee da ba daa
// 9: da ba dee da ba daa
// 10: da ba dee da ba daa
for (let i = 1; i <= 10; i++) {
    console.log(`${i}: da ba dee da ba daa`);
}


// 25
// 20
// 15
// 10
// 5
// 0
for (let i = 25; i >= 0; i -= 5) {
    console.log(i);
}
```









## 6. 루프(Loop): 무한 반복의 위험성 :(

반복문을 작성할 때, 조건문과 증감식을 치밀하게 계산하지 못하면 제어할 수 없는 무한 반복문이 된다. 반복문 작성 시, 각별히 유의하도록 하자.

```javascript
// infinity loop! Do not try again
// ===============================
// for (let i = 20; i >= 0; i++) {
//     console.log(i);
// }
```









## 7. 루프(Loop): 배열과 for 문 활용

```javascript
let animials = ['rabbit', 'lion', 'tiger', 'dog', 'cat', 'crocodile', 'mouse', 'monkey', 'horse'];

// 배열을 순서대로 참조
for (let i = 0; i < animials.length; i++) {
    console.log(i, animials[i]);
}

// 배열을 역순으로 참조
for (let i = animials.length-1; i >= 0; i--) {
    console.log(i, animials[i]);
}
```









## 8. 루프(Loop): 다차원 배열과 네스트 for 문

```javascript
// 0번째 줄
//     Kirsten
//     Erik
//     Namita
// 1번째 줄
//     Geoffrey
//     Juanita
//     Antonio
//     Kevin
// 2번째 줄
//     Yuma
//     Sakura
//     Jack
//     Erika
const seatingChart = [
    ['Kirsten', 'Erik', 'Namita'],
    ['Geoffrey', 'Juanita', 'Antonio', 'Kevin'],
    ['Yuma', 'Sakura', 'Jack', 'Erika'],
];

for (let i = 0; i < seatingChart.length; i++) {
    console.log(`${i}번째 줄`);
    for (let j = 0; j < seatingChart[i].length; j++) {
        console.log(`   ${seatingChart[i][j]}`);
    }
}
```







## 9. 루프(Loop): while 문

JS 의 while 문은 C와 비슷하다.

[예제 1]

```javascript
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
// 10
let i = 1;
while (i <= 10) {
    console.log(i);
    i++;
}
```



[예제 2]

```javascript
const passWord = '3663';

let guess = prompt('비밀번호를 입력해주세요.');
while(passWord != guess) {
    guess = prompt('비밀번호가 틀렸습니다. 다시 입력해주세요.');
}
console.log('Logged In');
```



[예제 3]

```javascript
let maximum = parseInt(prompt('Enter the maximum number!'));

const targetNum = Math.floor(Math.random() * maximum) + 1;
console.log(targetNum);

let guess = prompt('What is my number?');
while (targetNum != guess) {
    if (guess == 'q') break;
    if (targetNum > guess) {
        guess = parseInt(prompt('UP!'));
    }
    else {
        guess = parseInt(prompt('DOWN!'));
    }
}
console.log("Congulaturations!");
```









## 10. 루프(Loop): iterable 객체의 반복, for ... of 문

[iterable 참조 링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols)

for ... of 문과 iterable 객체를 함께 사용하면, 쉽게 iterable 객체에 있는 모든 요소를 탐색할 수 있다.

여기서 iterable 객체란, '반복 가능한' 이라는 의미로써 iterable 객체의 종류는 아래와 같다.

- String
- Array
- TypedArray
- Map
- Set 

하지만, 객체(Object)는 iterable 객체가 아니기 때문에, for .. of 문을 활용한 탐색이 불가함을 명심하자.

[예제 1]

```javascript
// String
for (let word of "HELLO") {
    console.log(word);
}

// Array
for (let num of [1, 2, 3, 4]) {
    console.log(num);
}
```



[예제 2]

```javascript
const seatingChart = [
    ['Kristen', 'Erik', 'Namita'],
    ['Geoffrey', 'Juanita', 'Antonio', 'Kevin'],
    ['Yuma', 'Sakura', 'Jack', 'Erika'],
];

// 다차원 배열의 모든 요소 탐색
for (let row of seatingChart) {
    for (let student of row) {
        console.log(student);
    }
}
```









## 11. 루프(Loop): 객체(Obejct)의 반복, for ... in 문

for .. in 문은 for .. of 에 비해 많이 사용되지 않지만 객체(Object)를 탐색할 때 주로 사용된다.

for .. in 과 객체를 함께 사용하면, 객체의 key 를 순서대로 탐색할 수 있다.

이렇게 순서대로 탐색한 key를 가지고, value에도 접근할 수 있다.

```javascript
const testScores = {
    keenan: 80,
    damon: 67,
    kim: 89,
    shawn: 91,
    marlon: 72,
    dwayne: 77,
    nadia: 83,
    elvira: 97,
    diedre: 81,
    vonnie: 60,
}

// keenan: 80
// damon: 67
// kim: 89
// shawn: 91
// marlon: 72
// dwayne: 77
// nadia: 83
// elvira: 97
// diedre: 81
// vonnie: 60
for (let name in testScores) {
    console.log(`${name}: ${testScores[name]}`);
}
```



- Object.values(객체) : 객체의 value를 순서대로 추출하여 배열로 만든다. (그런데, 막상 typeof를 찍어보면, 배열이 아닌 Object로 찍힌다...)

```javascript
const testScores = {
    keenan: 80,
    damon: 67,
    kim: 89,
    shawn: 91,
    marlon: 72,
    dwayne: 77,
    nadia: 83,
    elvira: 97,
    diedre: 81,
    vonnie: 60,
}

// 객체의 value를 순서대로 추출하여 배열로 구성
let name_array = Object.values(testScores);

// 80
// 67
// 89
// 91
// 72
// 77
// 83
// 97
// 81
// 60
for (let name of name_array) {
    console.log(name);
}
```



[연습-미니 프로젝트]

```javascript
// ================기능=================
// 'quit'을 입력할 때까지, 'What would you like to do?' 묻고 입력 대기
// 'new'-> 'Enter new todo' 묻고 입력대기 -> 콘솔에 '입력한 값 + added to list' 메시지 출력
// 'list' -> 'index 값: value' 출력
// 'delete' -> 'Enter index of todo to delete' 묻고 입력대기 -> 콘솔에 '입력한 값 + Removed' 메시지 출력
// 'quit' -> 콘솔에 'OK, YOU QUIT THE APP' 메시지 출력

let input = prompt('What would you like to do?');
const toDoList = [];

while(input !== 'quit') {
    if (input === 'new') {
        let tmp = prompt('Enter new todo');
        console.log(`${tmp} added to list`);
        toDoList.push(tmp);
        input = '';
    }
    else if (input === 'list') {
        console.log('**********');
        for (let i = 0; i < toDoList.length; i++) {
            console.log(`${i}: ${toDoList[i]}`);
        }
        console.log('**********');
        input = '';
    }
    else if (input === 'delete') {
        let del_i = parseInt(prompt('Enter index of todo to delete'));
        console.log(`${toDoList[del_i]} Removed`);
        toDoList.splice(del_i, 1);
        input = '';
    }
    input = prompt('What would you like to do?');
}
console.log('OK, YOU QUIT THE APP');
```









## 12. 함수(fuction): 종류

[예시 1 - 인수, 반환이 없는 함수]

```javascript
// <3
function printHeart() {
    console.log('<3');
}

printHeart();
```



[예시 2 - 인수가 하나이고, 반환이 없는 함수]

```javascript
// I HATE BEETS
// I HATE BEETS
// I HATE BEETS
function rant(message) {
    for (let i = 0; i < 3; i++) {
        console.log(message.toUpperCase());
    }
}

rant('I hate beets');
```



[예시 3 - 인수가 여러개이고, 반환이 없는 함수]

```javascript
function repeatGreetings(message, repeatTimes) {
    for (let i = 0; i < repeatTimes; i++) {
        console.log(message);
    }
}

// Hi
// Hi
// Hi
// Hi
// Hi
repeatGreetings('Hi', 5);
```



[예시 3 - 인수가 여러개이고, 반환이 없는 함수]

```javascript
function add(num1, num2) {
    let res;
    if (typeof(num1) !== 'number' || typeof(num2) !== 'number' ) {
        res = false;
        console.log(res);
        return res;
    }
    else {
        res = num1 + num2;
        console.log(res);
        return res; 
    }
}

// 6
add(1, 5);
// false
add('a', 1);
```









## 13. *함수(fuction): 표현식

이름이 없는 함수를 선언하여 변수 안에 저장하는 방식이다. 이 방식을 사용하면, 함수를 인수로 전달 받거나, 함수를 반환할 수 있게 된다.

반드시 함수 표현식을 기억하고 익숙하게 사용하도록 하자.

```javascript
const add = function(x, y) {
    return x + y;
}

// 3
console.log(add(1, 2));
```









## 14. 함수(fuction): 고차 함수

고차 함수의 종류:

- 다른 함수를 인수로 받는 함수
- 함수를 반환하는 함수

[예시 1 - 다른 함수를 인수로 받는 함수]

```javascript
function rollDie() {
    const roll = Math.floor(Math.random() * 6) + 1;
    console.log(roll);
}

// 고차 함수 정의
function callTenTimes(f) {
    for (let i = 0; i < 10; i++) {
        f();
    }
}

callTenTimes(rollDie);
```



[예시 2 - 함수를 반환하는 함수]

```javascript
function makeBetweenNum(min, max) {
    return function(num) {
        return num >= min && num <= max;
    }
}

const isAdult = makeBetweenNum(19, 64);
const isSenior = makeBetweenNum(65, 120);

// false
console.log(isAdult());
// true
console.log(isAdult(20));
// false
console.log(isAdult(18));


// false
console.log(isSenior());
// false
console.log(isSenior(121));
// true
console.log(isSenior(120));
```









## 15. 함수(fuction): 메서드 정의하기

메서드는 객체(Object)의 key에 종속된 함수를 의미한다. 이 때, function 키워드를 생략하여 단축할 수도 있다.

```javascript
const myMath = {
    PI: 3.141592,

    // 객체에 종속된 함수 == 메서드
    square: function (num) {
        return num*num;
    },

    // 메서드는 function 키워드를 생략할 수 있음
    cube(num) {
        return num ** 3;
    },
}

let myPI = myMath.PI;
let mySqaure = myMath.square(5);
let myCube = myMath.cube(6);

// 3.141592 25 216
console.log(myPI, mySqaure, myCube);
```

 







## 16. 함수(fuction): this 키워드

this 키워드를 사용하면 property 가 자신이 속해있는 객체(Object)를 참조할 수 있게 된다.

그래서, this 키워드를 사용하면 같은 객체 내의 다른 property 로 접근할 수 있게 된다. *실제로는 더 복잡하다고 함.

[예시 1]

```javascript
const person = {
    first: 'Dong Kyoo',
    last: 'Lee',
    fullName: function() {
        // 에러
        // console.log(first, last);

        // this 키워드로 객체(person)을 통해 다른 속성(first, last)에 각각 접근
        console.log(this.first, this.last);
    }
}

// Dong Kyoo Lee
person.fullName();
```



[예시 2]

```javascript
const hen = {
    name: 'Helen',
    eggCount: 0,
    layAnEgg() {
        this.eggCount += 1;
        return 'EGG';
    }
}

console.log(hen.name); // "Helen"
console.log(hen.eggCount); // 0
console.log(hen.layAnEgg()); // "EGG"
console.log(hen.layAnEgg()); // "EGG"
console.log(hen.eggCount); // 2
```









## 17. 배열 메서드: forEach

